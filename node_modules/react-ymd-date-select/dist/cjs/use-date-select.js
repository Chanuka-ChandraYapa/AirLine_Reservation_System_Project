"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useDateSelect = void 0;
const react_1 = require("react");
const format_1 = __importDefault(require("date-fns/format"));
const range_1 = require("./range");
const date_string_1 = require("./date-string");
const DEFAULT_FIRST_YEAR = 2000;
function parseSelectValue(value) {
    return parseInt(value);
}
function convertToSelectValue(value) {
    return value.toString();
}
function compileDefaultDate(opts) {
    const now = new Date();
    let defaultYear = null;
    if (opts.defaultYear != null) {
        if (opts.defaultYear === "now") {
            defaultYear = now.getFullYear();
        }
        else if (typeof opts.defaultYear === "number") {
            defaultYear = opts.defaultYear;
        }
    }
    let defaultMonth = null;
    if (opts.defaultMonth != null) {
        if (opts.defaultMonth === "now") {
            defaultMonth = now.getMonth() + 1;
        }
        else if (typeof opts.defaultMonth === "number") {
            defaultMonth = opts.defaultMonth;
        }
    }
    let defaultDay = null;
    if (opts.defaultDay != null) {
        if (opts.defaultDay === "now") {
            defaultDay = now.getDate();
        }
        else if (typeof opts.defaultDay === "number") {
            defaultDay = opts.defaultDay;
        }
    }
    return { defaultYear, defaultMonth, defaultDay };
}
const useDateSelect = (value, onChange, opts = {}) => {
    const [state, setState] = (0, react_1.useState)(() => {
        const { defaultYear, defaultMonth, defaultDay } = compileDefaultDate(opts);
        return {
            yearValue: defaultYear ? convertToSelectValue(defaultYear) : "",
            monthValue: defaultMonth ? convertToSelectValue(defaultMonth) : "",
            dayValue: defaultDay ? convertToSelectValue(defaultDay) : "",
            dateString: null,
            changeCount: 0, // HACK: Use this state as a dependency of the `useEffect` below so that `onChange` is called only when it should be.
        };
    });
    const updateDate = (0, react_1.useCallback)(({ year, month, day }) => {
        setState((curState) => {
            const yearValue = year !== null && year !== void 0 ? year : curState.yearValue;
            const monthValue = month !== null && month !== void 0 ? month : curState.monthValue;
            const dayValue = day !== null && day !== void 0 ? day : curState.dayValue;
            const dateString = (0, date_string_1.compileDateString)(parseSelectValue(yearValue), parseSelectValue(monthValue), parseSelectValue(dayValue));
            return {
                yearValue,
                monthValue,
                dayValue,
                dateString,
                changeCount: curState.changeCount + 1, // `updateDate` changes `state.changeCount` so that `onChange` is triggered.
            };
        });
    }, []);
    const setDate = (0, react_1.useCallback)((dateString) => {
        const { year, month, day } = (0, date_string_1.parseDateString)(dateString);
        setState((curState) => ({
            yearValue: year,
            monthValue: month,
            dayValue: day,
            dateString,
            changeCount: curState.changeCount, // This method does not update `state.changeCount` so that `onChange` is not triggered.
        }));
    }, []);
    // Sync from the state to the upper component through onChange when necessary.
    const mountedRef = (0, react_1.useRef)(false);
    (0, react_1.useEffect)(() => {
        if (!mountedRef.current) {
            return;
        }
        onChange(state.dateString || "");
    }, [state.changeCount]);
    (0, react_1.useEffect)(() => {
        mountedRef.current = true;
        return () => {
            mountedRef.current = false;
        };
    }, []);
    // Sync from the passed value to the state when necessary.
    (0, react_1.useEffect)(() => {
        if (typeof value !== "string") {
            return;
        }
        const dateValueAsString = state.dateString || "";
        if (dateValueAsString !== value) {
            setDate(value);
        }
    }, [setDate, value]);
    // Generate year, month, and day arrays based on locale and specified formats
    const locale = opts.locale;
    const yearFormat = opts.yearFormat;
    const rawYearOptions = (0, react_1.useMemo)(() => {
        const firstYear = opts.firstYear != null ? opts.firstYear : DEFAULT_FIRST_YEAR;
        const lastYear = opts.lastYear != null ? opts.lastYear : new Date().getFullYear();
        return (0, range_1.range)(firstYear, lastYear).map((i) => {
            const label = yearFormat
                ? (0, format_1.default)(new Date(i, 0, 1), yearFormat, { locale })
                : i.toString();
            return { value: convertToSelectValue(i), label };
        });
    }, [opts.firstYear, opts.lastYear, locale, yearFormat]);
    const monthFormat = opts.monthFormat;
    const monthOptions = (0, react_1.useMemo)(() => {
        return (0, range_1.range)(1, 12).map((i) => {
            const label = monthFormat
                ? (0, format_1.default)(new Date(1960, i - 1), monthFormat, { locale })
                : i.toString();
            return { label, value: convertToSelectValue(i) };
        });
    }, [locale, monthFormat]);
    const dayFormat = opts.dayFormat;
    const dayOptions = (0, react_1.useMemo)(() => {
        return (0, range_1.range)(1, 31).map((i) => {
            const label = dayFormat
                ? (0, format_1.default)(new Date(1960, 0, i), dayFormat, { locale })
                : i.toString();
            return { label, value: convertToSelectValue(i) };
        });
    }, [locale, dayFormat]);
    // If `state.yearValue` is not included in the year options, add it.
    const yearOptions = (0, react_1.useMemo)(() => {
        if (state.yearValue !== "" &&
            !rawYearOptions.some((o) => o.value === state.yearValue)) {
            let label;
            try {
                label = yearFormat
                    ? (0, format_1.default)(new Date(parseSelectValue(state.yearValue), 0, 1), yearFormat, { locale })
                    : state.yearValue;
            }
            catch (_a) {
                label = state.yearValue;
            }
            return rawYearOptions.concat({ label, value: state.yearValue });
        }
        return rawYearOptions;
    }, [state.yearValue, rawYearOptions]);
    return {
        yearValue: state.yearValue,
        monthValue: state.monthValue,
        dayValue: state.dayValue,
        yearOptions,
        monthOptions,
        dayOptions,
        onYearChange: (0, react_1.useCallback)((e) => {
            const value = typeof e === "string" ? e : e.target.value;
            updateDate({ year: value });
        }, [updateDate]),
        onMonthChange: (0, react_1.useCallback)((e) => {
            const value = typeof e === "string" ? e : e.target.value;
            updateDate({ month: value });
        }, [updateDate]),
        onDayChange: (0, react_1.useCallback)((e) => {
            const value = typeof e === "string" ? e : e.target.value;
            updateDate({ day: value });
        }, [updateDate]),
        dateValue: state.dateString,
        onDateChange: (0, react_1.useCallback)((e) => {
            const value = typeof e === "string" ? e : e.target.value;
            const { year, month, day } = (0, date_string_1.parseDateString)(value);
            updateDate({ year, month, day });
        }, [updateDate]),
        setDate,
    };
};
exports.useDateSelect = useDateSelect;
